# Rapture

![Logo](http://s2.postimg.org/gyhp28qwp/rapture_logo.png) </br>
[![Build Status](https://travis-ci.org/Travier/Rapture.svg?branch=master)](https://travis-ci.org/Travier/Rapture)



## Installation
:notebook: Rapture is still in early development so this guide serves only as a preview of Rapture.

### Install Rapture CLI
Rapture CLI allows you to easily create, deploy, and manage your apps from the commandline!
```bash

npm install -g rapture-cli
```
### Create/Boot new Rapture App
```bash
//create rapture app in directory <dir>
rapture init <dir>
cd <dir>

//run framework tests
rapture test

//boot app
rapture up

```
## Rapture App Basic's

### HTTP Server
<img height="130" href="https://github.com/hapijs/hapi" src="https://camo.githubusercontent.com/16f4a37b7e2086b6e44dcb0cdfaf9e41f5738278/68747470733a2f2f7261772e6769746875622e636f6d2f686170696a732f686170692f6d61737465722f696d616765732f686170692e706e67"></img>

At the heart of Rapture is [hapi](https://github.com/hapijs/hapi). The awesome server framework originally created by Walmart Labs. Rapture wraps around hapi and provides things such as Controllers, Models, Services and a folder structure for apps.

### Folder Structure
Rapture does come with a defined folder structure that is very easy and can be molded to fit your app needs!
```bash
/controllers - contains all controller classes
/models - contains all model classes
/services - contains all service classes
/core - contains all framework related files
/routes - contains all route files
/public - used to store all your frontend files
app.js - see below
config.js - see below
```

### app.js
app.js is the entry point into every Rapture app. Its main task is to import the App Module and boot the app.

**Example app.js:** </br>

```javascript
//import RAM
import App from './core/framework';

//boot Rapture app
App.boot();

```

### config.js
config.js houses all the various configuration settings of the framework.

**Example config.js:** </br>

```javascript
export default {
	//set debug mode
	debug:true,
	//settings related to hapi
	http:{
		//port http server should listen on
		port:3000
	}
}
```

### Routes
**/routes** contains all the files used to define routing in the application. Rapture will pickup each file in **/routes** and add the route definitions to hapi's router.

**Basic Route:**
this route file has one route definition which routes all requests from **/** to the **BaseController.index** method.

```javascript
export default function(App, Router) {
	//routes a GET request to the BaseController index method
	Router.route({
		method:'GET',
		path:'/',
		handler:'BaseController@index'
	});
}
```

:notebook: Rapture lets you define routing to your controller through the **handler** param of the route object. The String **BaseController@index** will direct the request to BaseController's index method.

### Controllers
**/controllers** contains all the controller classes rapture will autoload into the app.

**Basic Controller**
this controller has one method **index** which will return 'hello world' to the browser.

```javascript
import App from '../core/framework';

export default class BaseController {
	constructor() {
	}

	index(request, reply) {
		reply('hello world');
	}
}
```

#### Dependency Injection
Rapture includes a clean Dependency Injection(DI) layer for easily hinting dependencies in class constructors. Dependencies can be hinted into **Controllers**, **Models**, and **Services**.


#### Example
```javascript
import App from '../core/framework';


export default class BaseController {
	constructor(LoggerService) {
		this.logger = LoggerService;
	}

	index(request, reply) {
		this.logger.log('hello world was printed to client screen')
		reply('hello world');
	}
}
```
In this example the **BaseController** class is looking for the **LoggerService**. To resolve this dependency Rapture first looks at **LoggerService** and retrieves the **Service** part of the string. With this Rapture knows you are looking for a service named Logger. Rapture by default expects service files to be in the **/services** directory. In this case Rapture would look for file at **/services/Logger.js**.

From here Rapture will load your class, prepare your dependencies, and finally construct your class with those dependecies injected into the constructor. From there you can apply them in any way to your class!

:notebook: Captialization does matter when hinting dependencies and naming files. <br/>
:notebook: Currently Controllers can not be hinted into any type of class.

#### I don't want Depenendecy injection!
We understand not everyone wants to utilize this handy trick. If you'd like the same effect as the previous example without the Depenendecy injection your class can look like so:
```javascript
import App from '../core/framework';
import Logger from '../services/Logger';

export default class BaseController {
	constructor() {
		this.logger = Logger;
	}

	index(request, reply) {
		this.logger.log('hello world was printed to client screen')
		reply('hello world');
	}
}
```
### Sevices
**Basic Service:**
Services are pure es6 classes that can be imported into controllers. All service modules are stored in **/services**.

```javascript
export default class Logger {
  constructor() {

  }

  log(data) {
    console.log(data);
  }
}

```

### NOT READY FOR PRODUCTION
Rapture is just a toy project at the moment and should not be considered for production apps.
